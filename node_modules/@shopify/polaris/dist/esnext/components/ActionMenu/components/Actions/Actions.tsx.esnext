import React$1, { useRef, useState, useCallback, useMemo, useEffect } from 'react';
import { useFeatures } from '../../../../utilities/features/hooks.tsx.esnext';
import debounce$1 from 'lodash/debounce';
import { EventListener as EventListener$1 } from '../../../EventListener/EventListener.tsx.esnext';
import { useI18n } from '../../../../utilities/i18n/hooks.tsx.esnext';
import { classNames } from '../../../../utilities/css.ts.esnext';
import { ButtonGroup as ButtonGroup$1 } from '../../../ButtonGroup/ButtonGroup.tsx.esnext';
import { MenuAction as MenuAction$1 } from '../MenuAction/MenuAction.tsx.esnext';
import { SecondaryAction as SecondaryAction$1 } from '../SecondaryAction/SecondaryAction.tsx.esnext';
import { MenuGroup as MenuGroup$1 } from '../MenuGroup/MenuGroup.tsx.esnext';
import styles from './Actions.scss.esnext';

const ACTION_SPACING = 8;
function Actions({
  actions = [],
  groups = []
}) {
  const i18n = useI18n();
  const {
    newDesignLanguage
  } = useFeatures();
  const actionsLayoutRef = useRef(null);
  const menuGroupWidthRef = useRef(0);
  const availableWidthRef = useRef(0);
  const hasMeasured = useRef(false);
  const actionWidthsRef = useRef([]);
  const [activeMenuGroup, setActiveMenuGroup] = useState(undefined);
  const [measuredActions, setMeasuredActions] = useState({
    showable: [],
    rolledUp: []
  });
  const defaultRollupGroup = {
    title: i18n.translate('Polaris.Actions.moreActions'),
    actions: []
  };
  const lastMenuGroup = [...groups].pop();
  const lastMenuGroupWidth = [...actionWidthsRef.current].pop() || 0;
  const handleActionsOffsetWidth = useCallback(width => {
    actionWidthsRef.current = [...actionWidthsRef.current, width];
  }, []);
  const handleMenuGroupToggle = useCallback(group => setActiveMenuGroup(activeMenuGroup ? undefined : group), [activeMenuGroup]);
  const handleMenuGroupClose = useCallback(() => setActiveMenuGroup(undefined), []);
  const measureActions = useCallback(() => {
    if (!newDesignLanguage || actionWidthsRef.current.length === 0 || availableWidthRef.current === 0 || hasMeasured.current) {
      return;
    }

    const actionsAndGroups = [...actions, ...groups];

    if (actionsAndGroups.length === 1) {
      setMeasuredActions({
        showable: actionsAndGroups,
        rolledUp: []
      });
      return;
    }

    let currentAvailableWidth = availableWidthRef.current;
    let newShowableActions = [];
    let newRolledUpActions = [];
    actionsAndGroups.forEach((action, index) => {
      const canFitAction = actionWidthsRef.current[index] + menuGroupWidthRef.current + ACTION_SPACING + lastMenuGroupWidth <= currentAvailableWidth;

      if (canFitAction) {
        currentAvailableWidth -= actionWidthsRef.current[index] + ACTION_SPACING * 2;
        newShowableActions = [...newShowableActions, action];
      } else {
        currentAvailableWidth = 0; // Find last group if it exists and always render it as a rolled up action below

        if (action === lastMenuGroup) return;
        newRolledUpActions = [...newRolledUpActions, action];
      }
    });
    setMeasuredActions({
      showable: newShowableActions,
      rolledUp: newRolledUpActions
    }); // Set hasMeasured to true to prevent re-renders until viewport has been resized

    hasMeasured.current = true;
  }, [actions, groups, lastMenuGroup, lastMenuGroupWidth, newDesignLanguage]);
  const handleResize = useMemo(() => debounce$1(() => {
    if (!newDesignLanguage || !actionsLayoutRef.current) return;
    availableWidthRef.current = actionsLayoutRef.current.offsetWidth; // Set hasMeasured to false to allow re-measuring

    hasMeasured.current = false;
    measureActions();
  }, 50, {
    leading: false,
    trailing: true
  }), [newDesignLanguage, measureActions]);
  useEffect(() => {
    if (!actionsLayoutRef.current) {
      return;
    }

    availableWidthRef.current = actionsLayoutRef.current.offsetWidth;
    measureActions();
  }, [measureActions]);
  const className = classNames(styles.ActionsLayout, newDesignLanguage && styles.newDesignLanguage);
  const actionsMarkup = actions.map(action => {
    if (newDesignLanguage && measuredActions.showable.length > 0 || measuredActions.rolledUp.includes(action)) return null;
    const {
      content,
      onAction,
      ...rest
    } = action;
    return newDesignLanguage ? /*#__PURE__*/React$1.createElement(SecondaryAction$1, Object.assign({
      key: content,
      onClick: onAction
    }, rest, {
      getOffsetWidth: handleActionsOffsetWidth
    }), content) : /*#__PURE__*/React$1.createElement(MenuAction$1, Object.assign({
      key: content,
      content: content,
      onAction: onAction
    }, rest));
  });
  const rollUppableActionsMarkup = measuredActions.showable.length > 0 ? measuredActions.showable.map(action => action.content && /*#__PURE__*/React$1.createElement(SecondaryAction$1, Object.assign({
    key: action.content
  }, action, {
    getOffsetWidth: handleActionsOffsetWidth
  }), action.content)) : null;
  const groupsMarkup = [...groups, defaultRollupGroup].filter(group => {
    return groups.length === 0 && group === defaultRollupGroup ? group : group === lastMenuGroup || !measuredActions.rolledUp.some(rolledUpGroup => isMenuGroup(rolledUpGroup) && rolledUpGroup.title === group.title);
  }).map(group => {
    const {
      title,
      actions: groupActions,
      ...rest
    } = group;
    const finalRolledUpActions = measuredActions.rolledUp.reduce((memo, action) => {
      memo.push(...(isMenuGroup(action) ? action.actions : [action]));
      return memo;
    }, []);
    const isDefaultGroup = group === defaultRollupGroup;

    if (isDefaultGroup && groups.length === 0 && finalRolledUpActions.length > 0) {
      return /*#__PURE__*/React$1.createElement(MenuGroup$1, Object.assign({
        key: title,
        title: title,
        active: title === activeMenuGroup,
        actions: [...(finalRolledUpActions || actions), ...(!isDefaultGroup ? groupActions : [])]
      }, rest, {
        onOpen: handleMenuGroupToggle,
        onClose: handleMenuGroupClose,
        getOffsetWidth: handleActionsOffsetWidth
      }));
    } else if (!isDefaultGroup && (groups.length > 0 || groupActions.length || actions.length)) {
      return /*#__PURE__*/React$1.createElement(MenuGroup$1, Object.assign({
        key: title,
        title: title,
        active: title === activeMenuGroup,
        actions: [...(finalRolledUpActions || actions), ...(!isDefaultGroup ? groupActions : [])]
      }, rest, {
        onOpen: handleMenuGroupToggle,
        onClose: handleMenuGroupClose,
        getOffsetWidth: handleActionsOffsetWidth
      }));
    }
  });
  const groupedActionsMarkup = newDesignLanguage ? /*#__PURE__*/React$1.createElement(ButtonGroup$1, {
    spacing: "extraTight"
  }, rollUppableActionsMarkup, actionsMarkup, groupsMarkup) : /*#__PURE__*/React$1.createElement(React$1.Fragment, null, actionsMarkup, groupsMarkup);
  return /*#__PURE__*/React$1.createElement("div", {
    className: className,
    ref: actionsLayoutRef
  }, groupedActionsMarkup, /*#__PURE__*/React$1.createElement(EventListener$1, {
    event: "resize",
    handler: handleResize
  }));
}

function isMenuGroup(actionOrMenuGroup) {
  return 'title' in actionOrMenuGroup;
}

export { Actions };
