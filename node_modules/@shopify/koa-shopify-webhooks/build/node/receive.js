"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receiveWebhook = receiveWebhook;

var _crypto = require("crypto");

var _safeCompare = _interopRequireDefault(require("safe-compare"));

var _koaBodyparser = _interopRequireDefault(require("koa-bodyparser"));

var _koaMount = _interopRequireDefault(require("koa-mount"));

var _koaCompose = _interopRequireDefault(require("koa-compose"));

var _network = require("@shopify/network");

var _types = require("./types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function receiveWebhook({
  secret,
  path,
  onReceived = noop
}) {
  async function receiveWebhookMiddleware(ctx, next) {
    const hmac = ctx.get(_types.WebhookHeader.Hmac);
    const topic = ctx.get(_types.WebhookHeader.Topic);
    const domain = ctx.get(_types.WebhookHeader.Domain);
    const {
      rawBody
    } = ctx.request;
    const generatedHash = (0, _crypto.createHmac)('sha256', secret).update(rawBody, 'utf8').digest('base64');
    const graphqlTopic = topic.toUpperCase().replace(/\//g, '_');

    if ((0, _safeCompare.default)(generatedHash, hmac)) {
      ctx.res.statusCode = _network.StatusCode.Accepted;
      ctx.state.webhook = {
        topic: graphqlTopic,
        domain,
        payload: JSON.parse(rawBody)
      };
      await onReceived(ctx);
      await next();
    } else {
      ctx.res.statusCode = _network.StatusCode.Forbidden;
    }
  }

  const middleware = (0, _koaCompose.default)([(0, _koaBodyparser.default)(), receiveWebhookMiddleware]);
  return path ? (0, _koaMount.default)(path, middleware) : middleware;
}

function noop() {}