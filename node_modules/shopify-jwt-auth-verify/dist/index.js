"use strict";
exports.__esModule = true;
// Node crypto & bufferFrom
var buffer_1 = require("buffer");
var crypto = require("crypto");
// Utils
var atob = function (a) {
    if (a === void 0) { a = ''; }
    return buffer_1.Buffer.from(a, 'base64').toString('binary');
};
var base64UrlEncode = function (buffer) { return buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, ''); };
// is Verified and not expired
var isVerified = function (authorization, secret, cb) {
    // Early return for missing params
    if (!authorization || !secret) {
        console.error('authorization or app secret missing');
        return false;
    }
    // probably could be cleaned up this is dirty, straight string replace to remove the stragglers and split it. 
    var auth = authorization.replace('Bearer ', '').split('.');
    // will be passed to the optional call back
    var authObject = {
        header: atob(auth[0]),
        payload: atob(auth[1]),
        signature: auth[2]
    };
    var headerPayload = [auth[0], auth[1]].join('.');
    var signedBuffer = crypto.createHmac('sha256', secret).update(headerPayload).digest();
    var isVerified = authObject.signature === base64UrlEncode(signedBuffer);
    if (!isVerified) {
        console.error('Token is invalid');
        return false;
    }
    // validate not expired
    var payload = JSON.parse(authObject.payload);
    var time = new Date().getTime() / 1000;
    var isExpired = payload.exp <= time;
    if (isExpired) {
        console.error('Token is expired');
        return false;
    }
    // call the optional callback with the authObject
    if (cb) {
        cb(authObject);
    }
    // return valid
    return true;
};
exports["default"] = isVerified;
//# sourceMappingURL=index.js.map